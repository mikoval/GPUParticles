<html>
<body style="margin:0px;">


<script src="jquery.min.js"></script>
<script src="underscore.js"></script>
<script src="ShaderLoader.js"></script>
<script src="three.js"></script>

<script src="PhysicsRenderer.js"></script>
<link rel="stylesheet" type="text/css" href="canvas.css">

<script>
  

	var scene , camera , renderer  ;

	var SIZE = 16;
  var particleSize = 20;
  var bounce = 0.3;
  var cellSize = particleSize * 2;
  var particalsPerCell = 4;



	var simulation;
	var width = window.innerWidth; 
	var height = window.innerHeight;
  particlePositions = new THREE.WebGLRenderTarget( SIZE , SIZE, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter,type: THREE.FloatType, format: THREE.RGBAFormat});
  particlePositionsOld =  new THREE.WebGLRenderTarget( SIZE , SIZE, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter,type: THREE.FloatType,});
  particlePositionsTarget =  new THREE.WebGLRenderTarget( SIZE , SIZE, {minFilter: THREE.LinearFilter, magFilter: THREE.NearestFilter,type: THREE.FloatType,});
  var plane = new THREE.PlaneGeometry( width, height);

  var shaders = new ShaderLoader( './shaders' );


  shaders.load( 'partical-update'    , 'update'    , 'simulation' );
  shaders.load( 'partical-constrain'    , 'constrain'    , 'simulation' );
  shaders.load( 'partical-position-constrain'    , 'constrainPosition'    , 'simulation' );
  shaders.load( 'partical-collisions'    , 'collide'    , 'simulation' );
  shaders.load( 'vs-lookupW'  , 'lookup' , 'vertex'     );
  shaders.load( 'fs-lookupW'  , 'lookup' , 'fragment'   );
  shaders.load( 'fs-random'  , 'random' , 'fragment'   );
  shaders.load( 'vs-random'  , 'random' , 'vertex'   );
  shaders.shaderSetLoaded = function(){

    init();
    animate();

  }


  
  function init(){

      /*

         Default threejs stuff!

      */
      initBuckets();
     

      initScene();
      
       configShaders();

      createBackground();

      initParticles();

      

      
     
    //////
     
      ///////


  }
  function configShaders(){

    var sim = shaders.ss.collide;
    sim = sim.replace("&WIDTH", SIZE + ".0");
    sim = sim.replace("&HEIGHT", SIZE + ".0");
    sim = sim.replace("&PPC", particalsPerCell + ".0");
    sim = sim.replace("&CELLSIZE", cellSize + ".0");
    sim = sim.replace("&BW", numCellsHorizontal * particalsPerCell + ".0");
    sim = sim.replace("&BH", numCellsVertical * particalsPerCell + ".0");
    console.log(sim);
    shaders.ss.collide = sim;
  }
  function initBuckets(){
    
     
      numCellsHorizontal = Math.floor(width/cellSize);
      numCellsVertical = Math.floor(height/cellSize);
      
      buckets =  new Float32Array(numCellsHorizontal * particalsPerCell *numCellsVertical* particalsPerCell *4 );

     // console.log(numCellsHorizontal);
     // console.log(numCellsVertical);


    
    bucketTexture = new THREE.DataTexture( buckets, numCellsHorizontal * particalsPerCell ,   numCellsVertical * particalsPerCell, THREE.RGBAFormat, THREE.FloatType);

   

    

    
  }
  function initScene(){
      scene = new THREE.Scene();

      camera = new THREE.OrthographicCamera(-width/2, width/2, height/2, -height/2, 1, 10000 );
      camera.position.z = 100;

      renderer = new THREE.WebGLRenderer();
        

      renderer.setSize(width , height );

      document.body.appendChild( renderer.domElement );
      var element = renderer.domElement;
      element.style.width = "100%"
      element.style.height = "100%"

  }
  function createBackground(){ 

      var matBG = new THREE.MeshBasicMaterial({
          //map:null,
          //color:0x663333,
          

      });

      geoBG = new THREE.PlaneGeometry( width, height);

      for(var i =0 ; i < geoBG.vertices.length; i++){
        geoBG.vertices[i].z = -9000;
      }
      
      bg = new THREE.Mesh( geoBG, matBG );
      //bg.vertices.z = ;
      
      scene.add( bg );
  }
  function initParticles(){
      var geo = createLookupGeometry( SIZE );

     
      var mat = new THREE.ShaderMaterial({
        uniforms: {
          t_pos: { type: "t", value: null },
          res:{type:"v2", value: new THREE.Vector2(width, height)},
          size: {type:"f", value: particleSize}
        },
        vertexShader: shaders.vs.lookup,
        fragmentShader: shaders.fs.lookup,

      });
      
      

      particles = new THREE.Points( geo , mat );


     // particles.frustumCulled = false;

      scene.add( particles );

      createParticlePositions();
      createSimulation();



  }
  function createSimulation(){
    createUpdate();

    createConstrain();
    createCollide();
  }
  function createUpdate(){
    updateScene = new THREE.Scene();

    updateMaterial = new THREE.ShaderMaterial( {
        uniforms: {
          pos: { type: "t", value: null },
          posOld: { type: "t", value: null },
          res: {type:"v2", value :new THREE.Vector2(SIZE, SIZE)},

        },
        fragmentShader: shaders.ss.update,
        vertexShader: shaders.vs.random,
    } );
    updateObject = new THREE.Mesh( plane, updateMaterial );

    updateScene.add(updateObject);
  }
  function createConstrain(){
    //calculate new old positions for the verlet bounce
    constrainScene = new THREE.Scene();

    constrainMaterial = new THREE.ShaderMaterial( {
        uniforms: {
          pos: { type: "t", value: null },
          posOld: { type: "t", value: null },
          res: {type:"v2", value :new THREE.Vector2(SIZE, SIZE)},
          screenSize: {type:"v2", value :new THREE.Vector2(width, height)},
          size: {type:"f", value: particleSize},
          bounce: {type:"f", value: bounce},
        },
        fragmentShader: shaders.ss.constrain,
        vertexShader: shaders.vs.random,
    } );
    constrainObject = new THREE.Mesh( plane, constrainMaterial );

    constrainScene.add(constrainObject);

    //lock the actual positions to inside the screen
    constrainPositionScene = new THREE.Scene();

    constrainPositionMaterial = new THREE.ShaderMaterial( {
        uniforms: {
          pos: { type: "t", value: null },
          res: {type:"v2", value :new THREE.Vector2(SIZE, SIZE)},
          screenSize: {type:"v2", value :new THREE.Vector2(width, height)},
          size: {type:"f", value: particleSize},
        
        },
        fragmentShader: shaders.ss.constrainPosition,
        vertexShader: shaders.vs.random,
    } );


    constrainPositionObject = new THREE.Mesh( plane, constrainPositionMaterial );

    constrainPositionScene.add(constrainPositionObject);
  }
  function createCollide(){
    collideScene = new THREE.Scene();

    collideMaterial = new THREE.ShaderMaterial( {
        uniforms: {
          pos: { type: "t", value: null },
          buckets: { type: "t", value: null },
          res: {type:"v2", value :new THREE.Vector2(SIZE, SIZE)},
          size: {type:"f", value: particleSize},
          screenSize: {type:"v2", value :new THREE.Vector2(width, height)},

        },
        fragmentShader: shaders.ss.collide,
        vertexShader: shaders.vs.random,
    } );
    collideObject = new THREE.Mesh( plane, collideMaterial );

    collideScene.add(collideObject);
  }
  function createParticlePositions(){
     
      camera2 = new THREE.OrthographicCamera(-SIZE/2, SIZE/2, SIZE/2, -SIZE/2, 1, 10000 );
      camera2.position.z = 100;

      


        randomScene = new THREE.Scene();

        randomMaterial = new THREE.ShaderMaterial( {
            uniforms: {
              res: {type:"v2", value :new THREE.Vector2(width, height)},
            },
            fragmentShader: shaders.fs.random,
            vertexShader: shaders.vs.random,
        } );
        randomObject = new THREE.Mesh( plane, randomMaterial );

        randomScene.add(randomObject);
        renderer.render(randomScene,camera2,particlePositions,true);
        renderer.render(randomScene,camera2,particlePositionsOld,true);

        


  }
  function animate(){

    requestAnimationFrame( animate );
   
    
    calculateGridCells();

    for(var i = 0 ; i < 1; i++){
      updateParticles();
      for(var j = 0 ; j < 5; j++){
         collideParticles();
         constrainParticles();
      }
    }
    
   
    

    particles.material.uniforms.t_pos.value = particlePositions;
    bg.material.map = bucketTexture;
    renderer.render( scene , camera );

  } 



  function calculateGridCells(){
    var positions =  new Float32Array(SIZE * SIZE * 4)

    renderer.readRenderTargetPixels(particlePositions, 0, 0, SIZE, SIZE, positions);

    for(var i = 0; i < buckets.length; i++){
        buckets[i] = 0;
      }
   
    for(var i = 0 ; i < positions.length; i = i + 4){


      var px = positions[i];
      var py = positions[i + 1];
     
      var px = Math.floor(( px  + width/2) / cellSize);
      var py = Math.floor(( py + height/2 ) /  cellSize);
      

      var indX = px ;
      var indY = py ;
      //console.log(indX + ", " + indY)



     // indY = 0;
      //indX = 0;




      
      for(var k = 0; k < particalsPerCell; k++){
        for(var l = 0; l < particalsPerCell; l++){
           //var ind =( (indY * numCellsHorizontal * particalsPerCell+k)  + (indX + l) )* 4;

           var newIndY = (indY * particalsPerCell) + k;
           var newIndX = (indX * particalsPerCell) + l;
           //console.log(newIndX + ", " + newIndY)


           var ind = newIndY * (numCellsHorizontal * particalsPerCell * 4.0 ) + newIndX * 4.0;

           if(buckets[ind + 2] == 0){
            
            buckets[ind ] = i/4 %SIZE; 
            buckets[ind+1 ] = Math.floor(i/4/SIZE);
            //console.log(i/4 %SIZE + ", " + Math.floor(i/4/SIZE) )
            //buckets[ind ] = 0.1;
            // buckets[ind +1] = 1.0;
            //buckets[ind  + 2] = 1.0;
            buckets[ind  + 2] = 1.0;
            k = 1000;
            l = 1000;

           
           }
        }
      }
     

    }
    
    bucketTexture = new THREE.DataTexture( buckets, numCellsHorizontal * particalsPerCell,  numCellsVertical * particalsPerCell, THREE.RGBAFormat, THREE.FloatType);

    bucketTexture.needsUpdate = true;



    collideMaterial.uniforms.buckets.value = bucketTexture;




  }
  function collideParticles(){
    //get current pixels
  

    // handle collide
    collideMaterial.uniforms.pos.value = particlePositions;
    renderer.render(collideScene,camera2,particlePositionsTarget,true);
    var tmp1 = particlePositions
    var tmp3 = particlePositionsTarget


    particlePositions = tmp3;
    particlePositionsTarget = tmp1;
  }
  function constrainParticles(){
    //caolculate old positions for verlet collision
    constrainMaterial.uniforms.pos.value = particlePositions;
    constrainMaterial.uniforms.posOld.value = particlePositionsOld;
    renderer.render(constrainScene,camera2,particlePositionsTarget,true);
    var tmp1 = particlePositions
    var tmp2 = particlePositionsOld
    var tmp3 = particlePositionsTarget

    particlePositionsOld = tmp3;
    particlePositions = tmp1;
    particlePositionsTarget = tmp2;

    // lock positions to screen
    constrainPositionMaterial.uniforms.pos.value = particlePositions;
    renderer.render(constrainPositionScene,camera2,particlePositionsTarget,true);
    var tmp1 = particlePositions
    var tmp2 = particlePositionsOld
    var tmp3 = particlePositionsTarget


    particlePositions = tmp3;
    particlePositionsTarget = tmp1;


    
  }
  function updateParticles(){
     
    updateMaterial.uniforms.pos.value = particlePositions;
    updateMaterial.uniforms.posOld.value = particlePositionsOld;
    renderer.render(updateScene,camera2,particlePositionsTarget,true);
    var tmp1 = particlePositions
    var tmp2 = particlePositionsOld
    var tmp3 = particlePositionsTarget

    particlePositionsOld = tmp1;

    particlePositions = tmp3;
    particlePositionsTarget = tmp2;

    //particles.material.uniforms.t_pos.value = particlePositions;
  }
  function createLookupGeometry( size ){        
        
    var geo = new THREE.BufferGeometry();
    var positions = new Float32Array(  size * size * 3 );

    for ( var i = 0, j = 0, l = positions.length / 3; i < l; i ++, j += 3 ) {

      positions[ j     ] = ( i % size ) / size  ;
      positions[ j + 1 ] = Math.floor( i / size ) / size ;

    
    }
   // console.log(positions)

    var posA = new THREE.BufferAttribute( positions , 3 );
    geo.addAttribute( 'position', posA );
    

    return geo;
    
 }
</script>

</body>
</html>
